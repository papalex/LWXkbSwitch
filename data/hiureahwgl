<canvas id="canvas"></canvas>
<canvas id="sch"width="400" height="500"></canvas>


<!-- vertex shader -->
<script id="3d-vertex-shader" type="x-shader/x-vertex">
attribute vec4 a_position;
attribute vec4 a_color;

uniform mat4 u_matrix;

varying vec4 v_color;

void main() {
  // Multiply the position by the matrix.
  gl_Position = u_matrix * a_position;

  // Pass the color to the fragment shader.
  v_color = a_color;
}
</script>
<!-- fragment shader -->
<script id="3d-fragment-shader" type="x-shader/x-fragment">
precision mediump float;

// Passed in from the vertex shader.
varying vec4 v_color;

uniform vec4 u_colorMult;
uniform vec4 u_colorOffset;

void main() {
   gl_FragColor = v_color * u_colorMult + u_colorOffset;
}
</script>
<!--
for most samples webgl-utils only provides shader compiling/linking and
canvas resizing because why clutter the examples with code that's the same in every sample.
See http://webglfundamentals.org/webgl/lessons/webgl-boilerplate.html
and http://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
for webgl-utils, m3, m4, and webgl-lessons-ui.
-->
<script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
<script src="https://webglfundamentals.org/webgl/resources/m4.js"></script>
<script src="https://webglfundamentals.org/webgl/resources/primitives.js"></script>
<script>
	var HANDJS = HANDJS || {};

	(function () {
		// If the user agent already supports Pointer Events, do nothing
		if (window.PointerEvent)
			return;

		// Polyfilling indexOf for old browsers
		if (!Array.prototype.indexOf) {
			Array.prototype.indexOf = function (searchElement) {
				var t = Object(this);
				var len = t.length >>> 0;
				if (len === 0) {
					return -1;
				}
				var n = 0;
				if (arguments.length > 0) {
					n = Number(arguments[1]);
					if (n != n) { // shortcut for verifying if it's NaN
						n = 0;
					} else if (n != 0 && n != Infinity && n != -Infinity) {
						n = (n > 0 || -1) * Math.floor(Math.abs(n));
					}
				}
				if (n >= len) {
					return -1;
				}
				var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
				for (; k < len; k++) {
					if (k in t && t[k] === searchElement) {
						return k;
					}
				}
				return -1;
			};
		}
		// Polyfilling trim for old browsers
		if (!String.prototype.trim) {
			String.prototype.trim = function () {
				return this.replace(/^\s+|\s+$/, '');
			};
		}

		// Installing Hand.js
		var supportedEventsNames = ["pointerdown", "pointerup", "pointermove", "pointerover", "pointerout", "pointercancel", "pointerenter", "pointerleave"];
		var upperCaseEventsNames = ["PointerDown", "PointerUp", "PointerMove", "PointerOver", "PointerOut", "PointerCancel", "PointerEnter", "PointerLeave"];

		var POINTER_TYPE_TOUCH = "touch";
		var POINTER_TYPE_PEN = "pen";
		var POINTER_TYPE_MOUSE = "mouse";

		var previousTargets = {};

		var checkPreventDefault = function (node) {
			while (node && !node.handjs_forcePreventDefault) {
				node = node.parentNode;
			}
			return !!node || window.handjs_forcePreventDefault;
		};

		// Touch events
		var generateTouchClonedEvent = function (sourceEvent, newName, canBubble, newtarget) {
			// Considering touch events are almost like super mouse events
			var evObj;

			if (document.createEvent) {
				evObj = document.createEvent('MouseEvents');
				evObj.initMouseEvent(newName, canBubble, true, window, 1, sourceEvent.screenX, sourceEvent.screenY,
					sourceEvent.clientX, sourceEvent.clientY, sourceEvent.ctrlKey, sourceEvent.altKey,
					sourceEvent.shiftKey, sourceEvent.metaKey, sourceEvent.button, null);
			}
			else {
				evObj = document.createEventObject();
				evObj.screenX = sourceEvent.screenX;
				evObj.screenY = sourceEvent.screenY;
				evObj.clientX = sourceEvent.clientX;
				evObj.clientY = sourceEvent.clientY;
				evObj.ctrlKey = sourceEvent.ctrlKey;
				evObj.altKey = sourceEvent.altKey;
				evObj.shiftKey = sourceEvent.shiftKey;
				evObj.metaKey = sourceEvent.metaKey;
				evObj.button = sourceEvent.button;
			}
			// offsets
			if (evObj.offsetX === undefined) {
				if (sourceEvent.offsetX !== undefined) {

					// For Opera which creates readonly properties
					if (Object && Object.defineProperty !== undefined) {
						Object.defineProperty(evObj, "offsetX", {
							writable: true
						});
						Object.defineProperty(evObj, "offsetY", {
							writable: true
						});
					}

					evObj.offsetX = sourceEvent.offsetX;
					evObj.offsetY = sourceEvent.offsetY;
				} else if (Object && Object.defineProperty !== undefined) {
					Object.defineProperty(evObj, "offsetX", {
						get: function () {
							if (this.currentTarget && this.currentTarget.offsetLeft) {
								return sourceEvent.clientX - this.currentTarget.offsetLeft;
							}
							return sourceEvent.clientX;
						}
					});
					Object.defineProperty(evObj, "offsetY", {
						get: function () {
							if (this.currentTarget && this.currentTarget.offsetTop) {
								return sourceEvent.clientY - this.currentTarget.offsetTop;
							}
							return sourceEvent.clientY;
						}
					});
				}
				else if (sourceEvent.layerX !== undefined) {
					evObj.offsetX = sourceEvent.layerX - sourceEvent.currentTarget.offsetLeft;
					evObj.offsetY = sourceEvent.layerY - sourceEvent.currentTarget.offsetTop;
				}
			}

			// adding missing properties

			if (sourceEvent.isPrimary !== undefined)
				evObj.isPrimary = sourceEvent.isPrimary;
			else
				evObj.isPrimary = true;

			if (sourceEvent.pressure)
				evObj.pressure = sourceEvent.pressure;
			else {
				var button = 0;

				if (sourceEvent.which !== undefined)
					button = sourceEvent.which;
				else if (sourceEvent.button !== undefined) {
					button = sourceEvent.button;
				}
				evObj.pressure = (button == 0) ? 0 : 0.5;
			}


			if (sourceEvent.rotation)
				evObj.rotation = sourceEvent.rotation;
			else
				evObj.rotation = 0;

			// Timestamp
			if (sourceEvent.hwTimestamp)
				evObj.hwTimestamp = sourceEvent.hwTimestamp;
			else
				evObj.hwTimestamp = 0;

			// Tilts
			if (sourceEvent.tiltX)
				evObj.tiltX = sourceEvent.tiltX;
			else
				evObj.tiltX = 0;

			if (sourceEvent.tiltY)
				evObj.tiltY = sourceEvent.tiltY;
			else
				evObj.tiltY = 0;

			// Width and Height
			if (sourceEvent.height)
				evObj.height = sourceEvent.height;
			else
				evObj.height = 0;

			if (sourceEvent.width)
				evObj.width = sourceEvent.width;
			else
				evObj.width = 0;

			// preventDefault
			evObj.preventDefault = function () {
				if (sourceEvent.preventDefault !== undefined)
					sourceEvent.preventDefault();
			};

			// stopPropagation
			if (evObj.stopPropagation !== undefined) {
				var current = evObj.stopPropagation;
				evObj.stopPropagation = function () {
					if (sourceEvent.stopPropagation !== undefined)
						sourceEvent.stopPropagation();
					current.call(this);
				};
			}

			// Pointer values
			evObj.pointerId = sourceEvent.pointerId;
			evObj.pointerType = sourceEvent.pointerType;

			switch (evObj.pointerType) {// Old spec version check
				case 2:
					evObj.pointerType = POINTER_TYPE_TOUCH;
					break;
				case 3:
					evObj.pointerType = POINTER_TYPE_PEN;
					break;
				case 4:
					evObj.pointerType = POINTER_TYPE_MOUSE;
					break;
			}

			// Fire event
			if (newtarget)
				newtarget.dispatchEvent(evObj);
			else if (sourceEvent.target) {
				sourceEvent.target.dispatchEvent(evObj);
			} else {
				sourceEvent.srcElement.fireEvent("on" + getMouseEquivalentEventName(newName), evObj); // We must fallback to mouse event for very old browsers
			}
		};

		var generateMouseProxy = function (evt, eventName, canBubble, target) {
			evt.pointerId = 1;
			evt.pointerType = POINTER_TYPE_MOUSE;
			generateTouchClonedEvent(evt, eventName, canBubble, target);
		};

		var generateTouchEventProxy = function (name, touchPoint, target, eventObject, canBubble) {
			var touchPointId = touchPoint.identifier + 2; // Just to not override mouse id

			touchPoint.pointerId = touchPointId;
			touchPoint.pointerType = POINTER_TYPE_TOUCH;
			touchPoint.currentTarget = target;

			if (eventObject.preventDefault !== undefined) {
				touchPoint.preventDefault = function () {
					eventObject.preventDefault();
				};
			}

			generateTouchClonedEvent(touchPoint, name, canBubble, target);
		};

		var checkEventRegistration = function (node, eventName) {
			return node.__handjsGlobalRegisteredEvents && node.__handjsGlobalRegisteredEvents[eventName];
		}
		var findEventRegisteredNode = function (node, eventName) {
			while (node && !checkEventRegistration(node, eventName))
				node = node.parentNode;
			if (node)
				return node;
			else if (checkEventRegistration(window, eventName))
				return window;
		};

		var generateTouchEventProxyIfRegistered = function (eventName, touchPoint, target, eventObject, canBubble) { // Check if user registered this event
			if (findEventRegisteredNode(target, eventName)) {
				generateTouchEventProxy(eventName, touchPoint, target, eventObject, canBubble);
			}
		};

		//var handleOtherEvent = function (eventObject, name, useLocalTarget, checkRegistration) {
		//    if (eventObject.preventManipulation)
		//        eventObject.preventManipulation();

		//    for (var i = 0; i < eventObject.changedTouches.length; ++i) {
		//        var touchPoint = eventObject.changedTouches[i];

		//        if (useLocalTarget) {
		//            previousTargets[touchPoint.identifier] = touchPoint.target;
		//        }

		//        if (checkRegistration) {
		//            generateTouchEventProxyIfRegistered(name, touchPoint, previousTargets[touchPoint.identifier], eventObject, true);
		//        } else {
		//            generateTouchEventProxy(name, touchPoint, previousTargets[touchPoint.identifier], eventObject, true);
		//        }
		//    }
		//};

		var getMouseEquivalentEventName = function (eventName) {
			return eventName.toLowerCase().replace("pointer", "mouse");
		};

		var getPrefixEventName = function (prefix, eventName) {
			var upperCaseIndex = supportedEventsNames.indexOf(eventName);
			var newEventName = prefix + upperCaseEventsNames[upperCaseIndex];

			return newEventName;
		};

		var registerOrUnregisterEvent = function (item, name, func, enable) {
			if (item.__handjsRegisteredEvents === undefined) {
				item.__handjsRegisteredEvents = [];
			}

			if (enable) {
				if (item.__handjsRegisteredEvents[name] !== undefined) {
					item.__handjsRegisteredEvents[name]++;
					return;
				}

				item.__handjsRegisteredEvents[name] = 1;
				item.addEventListener(name, func, false);
			} else {

				if (item.__handjsRegisteredEvents.indexOf(name) !== -1) {
					item.__handjsRegisteredEvents[name]--;

					if (item.__handjsRegisteredEvents[name] != 0) {
						return;
					}
				}
				item.removeEventListener(name, func);
				item.__handjsRegisteredEvents[name] = 0;
			}
		};

		var setTouchAware = function (item, eventName, enable) {
			// Leaving tokens
			if (!item.__handjsGlobalRegisteredEvents) {
				item.__handjsGlobalRegisteredEvents = [];
			}
			if (enable) {
				if (item.__handjsGlobalRegisteredEvents[eventName] !== undefined) {
					item.__handjsGlobalRegisteredEvents[eventName]++;
					return;
				}
				item.__handjsGlobalRegisteredEvents[eventName] = 1;
			} else {
				if (item.__handjsGlobalRegisteredEvents[eventName] !== undefined) {
					item.__handjsGlobalRegisteredEvents[eventName]--;
					if (item.__handjsGlobalRegisteredEvents[eventName] < 0) {
						item.__handjsGlobalRegisteredEvents[eventName] = 0;
					}
				}
			}

			if (!window.MSPointerEvent) {
				switch (eventName) {
					case "pointerenter":
						if (item.onmouseenter !== undefined) {
							registerOrUnregisterEvent(item, "mouseenter", function (evt) { generateMouseProxy(evt, eventName); }, enable);
						}
						break;
					case "pointerleave":
						if (item.onmouseleave !== undefined) {
							registerOrUnregisterEvent(item, "mouseleave", function (evt) { generateMouseProxy(evt, eventName); }, enable);
						}
						break;
				}
			}
		};

		// Intercept addEventListener calls by changing the prototype
		var interceptAddEventListener = function (root) {
			var current = root.prototype ? root.prototype.addEventListener : root.addEventListener;

			var customAddEventListener = function (name, func, capture) {
				// Branch when a PointerXXX is used
				if (supportedEventsNames.indexOf(name) != -1) {
					setTouchAware(this, name, true);
				}

				if (current === undefined) {
					this.attachEvent("on" + getMouseEquivalentEventName(name), func);
				} else {
					current.call(this, name, func, capture);
				}
			};

			if (root.prototype) {
				root.prototype.addEventListener = customAddEventListener;
			} else {
				root.addEventListener = customAddEventListener;
			}
		};

		// Intercept removeEventListener calls by changing the prototype
		var interceptRemoveEventListener = function (root) {
			var current = root.prototype ? root.prototype.removeEventListener : root.removeEventListener;

			var customRemoveEventListener = function (name, func, capture) {
				// Release when a PointerXXX is used
				if (supportedEventsNames.indexOf(name) != -1) {
					setTouchAware(this, name, false);
				}

				if (current === undefined) {
					this.detachEvent(getMouseEquivalentEventName(name), func);
				} else {
					current.call(this, name, func, capture);
				}
			};
			if (root.prototype) {
				root.prototype.removeEventListener = customRemoveEventListener;
			} else {
				root.removeEventListener = customRemoveEventListener;
			}
		};

		// Hooks
		interceptAddEventListener(window);
		interceptAddEventListener(window.HTMLElement || window.Element);
		interceptAddEventListener(document);
		interceptAddEventListener(HTMLBodyElement);
		interceptAddEventListener(HTMLDivElement);
		interceptAddEventListener(HTMLImageElement);
		interceptAddEventListener(HTMLUListElement);
		interceptAddEventListener(HTMLAnchorElement);
		interceptAddEventListener(HTMLLIElement);
		interceptAddEventListener(HTMLTableElement);
		if (window.HTMLSpanElement) {
			interceptAddEventListener(HTMLSpanElement);
		}
		if (window.HTMLCanvasElement) {
			interceptAddEventListener(HTMLCanvasElement);
		}
		if (window.SVGElement) {
			interceptAddEventListener(SVGElement);
		}

		interceptRemoveEventListener(window);
		interceptRemoveEventListener(window.HTMLElement || window.Element);
		interceptRemoveEventListener(document);
		interceptRemoveEventListener(HTMLBodyElement);
		interceptRemoveEventListener(HTMLDivElement);
		interceptRemoveEventListener(HTMLImageElement);
		interceptRemoveEventListener(HTMLUListElement);
		interceptRemoveEventListener(HTMLAnchorElement);
		interceptRemoveEventListener(HTMLLIElement);
		interceptRemoveEventListener(HTMLTableElement);
		if (window.HTMLSpanElement) {
			interceptRemoveEventListener(HTMLSpanElement);
		}
		if (window.HTMLCanvasElement) {
			interceptRemoveEventListener(HTMLCanvasElement);
		}
		if (window.SVGElement) {
			interceptRemoveEventListener(SVGElement);
		}

		// Prevent mouse event from being dispatched after Touch Events action
		var touching = false;
		var touchTimer = -1;

		function setTouchTimer() {
			touching = true;
			clearTimeout(touchTimer);
			touchTimer = setTimeout(function () {
				touching = false;
			}, 700);
			// 1. Mobile browsers dispatch mouse events 300ms after touchend
			// 2. Chrome for Android dispatch mousedown for long-touch about 650ms
			// Result: Blocking Mouse Events for 700ms.
		}

		function getDomUpperHierarchy(node) {
			var nodes = [];
			if (node) {
				nodes.unshift(node);
				while (node.parentNode) {
					nodes.unshift(node.parentNode);
					node = node.parentNode;
				}
			}
			return nodes;
		}

		function getFirstCommonNode(node1, node2) {
			var parents1 = getDomUpperHierarchy(node1);
			var parents2 = getDomUpperHierarchy(node2);

			var lastmatch = null
			while (parents1.length > 0 && parents1[0] == parents2.shift())
				lastmatch = parents1.shift();
			return lastmatch;
		}

		//generateProxy receives a node to dispatch the event
		function dispatchPointerEnter(currentTarget, relatedTarget, generateProxy) {
			var commonParent = getFirstCommonNode(currentTarget, relatedTarget);
			var node = currentTarget;
			var nodelist = [];
			while (node && node != commonParent) {//target range: this to the direct child of parent relatedTarget
				if (checkEventRegistration(node, "pointerenter")) //check if any parent node has pointerenter
					nodelist.push(node);
				node = node.parentNode;
			}
			while (nodelist.length > 0)
				generateProxy(nodelist.pop());
		}

		//generateProxy receives a node to dispatch the event
		function dispatchPointerLeave(currentTarget, relatedTarget, generateProxy) {
			var commonParent = getFirstCommonNode(currentTarget, relatedTarget);
			var node = currentTarget;
			while (node && node != commonParent) {//target range: this to the direct child of parent relatedTarget
				if (checkEventRegistration(node, "pointerleave"))//check if any parent node has pointerleave
					generateProxy(node);
				node = node.parentNode;
			}
		}

		// Handling events on window to prevent unwanted super-bubbling
		// All mouse events are affected by touch fallback
		function applySimpleEventTunnels(nameGenerator, eventGenerator) {
			["pointerdown", "pointermove", "pointerup", "pointerover", "pointerout"].forEach(function (eventName) {
				window.addEventListener(nameGenerator(eventName), function (evt) {
					if (!touching && findEventRegisteredNode(evt.target, eventName))
						eventGenerator(evt, eventName, true);
				});
			});
			if (window['on' + nameGenerator("pointerenter").toLowerCase()] === undefined)
				window.addEventListener(nameGenerator("pointerover"), function (evt) {
					if (touching)
						return;
					var foundNode = findEventRegisteredNode(evt.target, "pointerenter");
					if (!foundNode || foundNode === window)
						return;
					else if (!foundNode.contains(evt.relatedTarget)) {
						dispatchPointerEnter(foundNode, evt.relatedTarget, function (targetNode) {
							eventGenerator(evt, "pointerenter", false, targetNode);
						});
					}
				});
			if (window['on' + nameGenerator("pointerleave").toLowerCase()] === undefined)
				window.addEventListener(nameGenerator("pointerout"), function (evt) {
					if (touching)
						return;
					var foundNode = findEventRegisteredNode(evt.target, "pointerleave");
					if (!foundNode || foundNode === window)
						return;
					else if (!foundNode.contains(evt.relatedTarget)) {
						dispatchPointerLeave(foundNode, evt.relatedTarget, function (targetNode) {
							eventGenerator(evt, "pointerleave", false, targetNode);
						});
					}
				});
		}

		(function () {
			if (window.MSPointerEvent) {
				//IE 10
				applySimpleEventTunnels(
					function (name) { return getPrefixEventName("MS", name); },
					generateTouchClonedEvent);
			}
			else {
				applySimpleEventTunnels(getMouseEquivalentEventName, generateMouseProxy);

				// Handling move on window to detect pointerleave/out/over
				if (window.ontouchstart !== undefined) {
					window.addEventListener('touchstart', function (eventObject) {
						for (var i = 0; i < eventObject.changedTouches.length; ++i) {
							var touchPoint = eventObject.changedTouches[i];
							previousTargets[touchPoint.identifier] = touchPoint.target;

							generateTouchEventProxyIfRegistered("pointerover", touchPoint, touchPoint.target, eventObject, true);

							//pointerenter should not be bubbled
							dispatchPointerEnter(touchPoint.target, null, function (targetNode) {
								generateTouchEventProxy("pointerenter", touchPoint, targetNode, eventObject, false);
							})

							generateTouchEventProxyIfRegistered("pointerdown", touchPoint, touchPoint.target, eventObject, true);
						}
						setTouchTimer();
					});

					window.addEventListener('touchend', function (eventObject) {
						for (var i = 0; i < eventObject.changedTouches.length; ++i) {
							var touchPoint = eventObject.changedTouches[i];
							var currentTarget = previousTargets[touchPoint.identifier];

							generateTouchEventProxyIfRegistered("pointerup", touchPoint, currentTarget, eventObject, true);
							generateTouchEventProxyIfRegistered("pointerout", touchPoint, currentTarget, eventObject, true);

							//pointerleave should not be bubbled
							dispatchPointerLeave(currentTarget, null, function (targetNode) {
								generateTouchEventProxy("pointerleave", touchPoint, targetNode, eventObject, false);
							})
						}
						setTouchTimer();
					});

					window.addEventListener('touchmove', function (eventObject) {
						for (var i = 0; i < eventObject.changedTouches.length; ++i) {
							var touchPoint = eventObject.changedTouches[i];
							var newTarget = document.elementFromPoint(touchPoint.clientX, touchPoint.clientY);
							var currentTarget = previousTargets[touchPoint.identifier];

							// If force preventDefault
							if (currentTarget && checkPreventDefault(currentTarget) === true)
								eventObject.preventDefault();

							generateTouchEventProxyIfRegistered("pointermove", touchPoint, currentTarget, eventObject, true);

							if (currentTarget === newTarget) {
								continue; // We can skip this as the pointer is effectively over the current target
							}

							if (currentTarget) {
								// Raise out
								generateTouchEventProxyIfRegistered("pointerout", touchPoint, currentTarget, eventObject, true);

								// Raise leave
								if (!currentTarget.contains(newTarget)) { // Leave must be called if the new target is not a child of the current
									dispatchPointerLeave(currentTarget, newTarget, function (targetNode) {
										generateTouchEventProxy("pointerleave", touchPoint, targetNode, eventObject, false);
									});
								}
							}

							if (newTarget) {
								// Raise over
								generateTouchEventProxyIfRegistered("pointerover", touchPoint, newTarget, eventObject, true);

								// Raise enter
								if (!newTarget.contains(currentTarget)) { // Leave must be called if the new target is not the parent of the current
									dispatchPointerEnter(newTarget, currentTarget, function (targetNode) {
										generateTouchEventProxy("pointerenter", touchPoint, targetNode, eventObject, false);
									})
								}
							}
							previousTargets[touchPoint.identifier] = newTarget;
						}
						setTouchTimer();
					});

					window.addEventListener('touchcancel', function (eventObject) {
						for (var i = 0; i < eventObject.changedTouches.length; ++i) {
							var touchPoint = eventObject.changedTouches[i];

							generateTouchEventProxyIfRegistered("pointercancel", touchPoint, previousTargets[touchPoint.identifier], eventObject, true);
						}
					});
				}
			}
		})();


		// Extension to navigator
		if (navigator.pointerEnabled === undefined) {

			// Indicates if the browser will fire pointer events for pointing input
			navigator.pointerEnabled = true;

			// IE
			if (navigator.msPointerEnabled) {
				navigator.maxTouchPoints = navigator.msMaxTouchPoints;
			}
		}

		// Handling touch-action css rule
		if (document.styleSheets && document.addEventListener) {
			document.addEventListener("DOMContentLoaded", function () {
				if (HANDJS.doNotProcessCSS || document.body.style.touchAction !== undefined) {//Chrome is trying to implement touch-action before Pointer Events listeners
					return;
				}

				var globalRegex = new RegExp(".+?{.*?}", "m");
				var selectorRegex = new RegExp(".+?{", "m");
				var filterStylesheet = function (unfilteredSheet) {
					var filter = globalRegex.exec(unfilteredSheet);
					if (!filter) {
						return;
					}
					var block = filter[0];
					unfilteredSheet = unfilteredSheet.replace(block, "").trim();
					var selectorText = selectorRegex.exec(block)[0].replace("{", "").trim();

					// Checking if the user wanted to deactivate the default behavior
					if (block.replace(/\s/g, "").indexOf("touch-action:none") != -1) {
						var elements = document.querySelectorAll(selectorText);

						for (var elementIndex = 0; elementIndex < elements.length; elementIndex++) {
							var element = elements[elementIndex];

							if (element.style.msTouchAction !== undefined) {
								element.style.msTouchAction = "none";
							}
							else {
								element.handjs_forcePreventDefault = true;
							}
						}
					}
					return unfilteredSheet;
				}
				var processStylesheet = function (unfilteredSheet) {
					if (window.setImmediate) {//not blocking UI interaction for a long time
						if (unfilteredSheet)
							setImmediate(processStylesheet, filterStylesheet(unfilteredSheet));
					}
					else {
						while (unfilteredSheet) {
							unfilteredSheet = filterStylesheet(unfilteredSheet);
						}
					}
				}; // Looking for touch-action in referenced stylesheets
				try {
					for (var index = 0; index < document.styleSheets.length; index++) {
						var sheet = document.styleSheets[index];

						if (sheet.href == undefined) { // it is an inline style
							continue;
						}

						// Loading the original stylesheet
						var xhr = new XMLHttpRequest();
						xhr.open("get", sheet.href, false);
						xhr.send();

						var unfilteredSheet = xhr.responseText.replace(/(\n|\r)/g, "");

						processStylesheet(unfilteredSheet);
					}
				} catch (e) {
					// Silently fail...
				}

				// Looking for touch-action in inline styles
				var styles = document.getElementsByTagName("style");
				for (var index = 0; index < styles.length; index++) {
					var inlineSheet = styles[index];

					var inlineUnfilteredSheet = inlineSheet.innerHTML.replace(/(\n|\r)/g, "").trim();

					processStylesheet(inlineUnfilteredSheet);
				}
			}, false);
		}

	})();
</script>
<script>
	"use strict";

	var TRS = function() {
		this.translation = [0, 0, 0];
		this.rotation = [0, 0, 0];
		this.scale = [1, 1, 1];
	};

	TRS.prototype.getMatrix = function(dst) {
		dst = dst || new Float32Array(16);
		var t = this.translation;
		var r = this.rotation;
		var s = this.scale;
		m4.translation(t[0], t[1], t[2], dst);
		m4.xRotate(dst, r[0], dst);
		m4.yRotate(dst, r[1], dst);
		m4.zRotate(dst, r[2], dst);
		m4.scale(dst, s[0], s[1], s[2], dst);
		return dst;
	};

	var Node = function(source) {
		this.children = [];
		this.localMatrix = m4.identity();
		this.worldMatrix = m4.identity();
		this.source = source;
	};

	Node.prototype.setParent = function(parent) {
// remove us from our parent
		if (this.parent) {
			var ndx = this.parent.children.indexOf(this);
			if (ndx >= 0) {
				this.parent.children.splice(ndx, 1);
			}
		}

// Add us to our new parent
		if (parent) {
			parent.children.push(this);
		}
		this.parent = parent;
	};

	Node.prototype.updateWorldMatrix = function(parentWorldMatrix) {

		var source = this.source;
		if (source) {
			source.getMatrix(this.localMatrix);
		}

		if (parentWorldMatrix) {
// a matrix was passed in so do the math
			m4.multiply(parentWorldMatrix, this.localMatrix, this.worldMatrix);
		} else {
// no matrix was passed in so just copy local to world
			m4.copy(this.localMatrix, this.worldMatrix);
		}

// now process all the children
		var worldMatrix = this.worldMatrix
		this.children.forEach(function(child) {
			child.updateWorldMatrix(worldMatrix);
		});
	};



	function main() {
// Get A WebGL context
		/** @type {HTMLCanvasElement} */
		var canvas = document.getElementById("canvas");
		var gl = canvas.getContext("webgl");
		if (!gl) {
			return;
		}

		var createFlattenedVertices = function(gl, vertices) {
			var last;
			return webglUtils.createBufferInfoFromArrays(
				gl,
				primitives.makeRandomVertexColors(
					primitives.deindexVertices(vertices),
					{
						vertsPerColor: 1,
						rand: function(ndx, channel) {
							if (channel == 0) {
								last = 128 + Math.random() * 128 | 0;
							}
							return channel < 3 ? last : 255;
						}
					})
			);
		};

		var cubeBufferInfo = createFlattenedVertices(gl, primitives.createCubeVertices(1));

// setup GLSL program
		var programInfo = webglUtils.createProgramInfo(gl, ["3d-vertex-shader", "3d-fragment-shader"]);

		function degToRad(d) {
			return d * Math.PI / 180;
		}

		function rand(min, max) {
			return Math.random() * (max - min) + min;
		}

		function emod(x, n) {
			return x >= 0 ? (x % n) : ((n - (-x % n)) % n);
		};


		var cameraAngleRadians = degToRad(0);
		var fieldOfViewRadians = degToRad(60);
		var cameraHeight = 50;

		var objectsToDraw = [];
		var objects = [];
		var nodeInfosByName = {};

// Let's make all the nodes
		var blockGuyNodeDescriptions =
			{
				name: "point between feet",
				draw: false,
				children: [
					{
						name: "waist",
						translation: [0, 3, 0],
						children: [
							{
								name: "torso",
								translation: [0, 2, 0],
								children: [
									{
										name: "neck",
										translation: [0, 1, 0],
										children: [
											{
												name: "head",
												translation: [0, 1, 0],
											},
										],
									},
									{
										name: "left-arm",
										translation: [-1, 0, 0],
										children: [
											{
												name: "left-forearm",
												translation: [-1, 0, 0],
												children: [
													{
														name: "left-hand",
														translation: [-1, 0, 0],
													},
												],
											},
										],
									},
									{
										name: "right-arm",
										translation: [1, 0, 0],
										children: [
											{
												name: "right-forearm",
												translation: [1, 0, 0],
												children: [
													{
														name: "right-hand",
														translation: [1, 0, 0],
													},
												],
											},
										],
									},
								],
							},
							{
								name: "left-leg",
								translation: [-1, -1, 0],
								children: [
									{
										name: "left-calf",
										translation: [0, -1, 0],
										children: [
											{
												name: "left-foot",
												translation: [0, -1, 0],
											},
										],
									}
								],
							},
							{
								name: "right-leg",
								translation: [1, -1, 0],
								children: [
									{
										name: "right-calf",
										translation: [0, -1, 0],
										children: [
											{
												name: "right-foot",
												translation: [0, -1, 0],
											},
										],
									}
								],
							},
						],
					},
				],
			};

		function makeNode(nodeDescription) {
			var trs  = new TRS();
			var node = new Node(trs);
			nodeInfosByName[nodeDescription.name] = {
				trs: trs,
				node: node,
			};
			trs.translation = nodeDescription.translation || trs.translation;
			if (nodeDescription.draw !== false) {
				node.drawInfo = {
					uniforms: {
						u_colorOffset: [0, 0, 0.6, 0],
						u_colorMult: [0.4, 0.4, 0.4, 1],
					},
					programInfo: programInfo,
					bufferInfo: cubeBufferInfo,
				};
				objectsToDraw.push(node.drawInfo);
				objects.push(node);
			}
			makeNodes(nodeDescription.children).forEach(function(child) {
				child.setParent(node);
			});
			return node;
		}

		function makeNodes(nodeDescriptions) {
			return nodeDescriptions ? nodeDescriptions.map(makeNode) : [];
		}

		var scene = makeNode(blockGuyNodeDescriptions);

		requestAnimationFrame(drawScene);

// Draw the scene.
		function drawScene(time) {
			time *= 0.001;

			webglUtils.resizeCanvasToDisplaySize(gl.canvas);

// Tell WebGL how to convert from clip space to pixels
			gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

			gl.enable(gl.CULL_FACE);
			gl.enable(gl.DEPTH_TEST);

// Clear the canvas AND the depth buffer.
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

// Compute the projection matrix
			var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
			var projectionMatrix =
				m4.perspective(fieldOfViewRadians, aspect, 1, 2000);

// Compute the camera's matrix using look at.
			var cameraPosition = [4, 3.5, 10];
			var target = [0, 3.5, 0];
			var up = [0, 1, 0];
			var cameraMatrix = m4.lookAt(cameraPosition, target, up);

// Make a view matrix from the camera matrix.
			var viewMatrix = m4.inverse(cameraMatrix);

			var viewProjectionMatrix = m4.multiply(projectionMatrix, viewMatrix);

// Draw objects

// Update all world matrices in the scene graph
			scene.updateWorldMatrix();

			var adjust;
			var speed = 3;
			var c = time * speed;
			adjust = Math.abs(Math.sin(c));
			nodeInfosByName["point between feet"].trs.translation[1] = adjust;
			adjust = Math.sin(c);
			nodeInfosByName["left-leg" ].trs.rotation[0] =  adjust;
			nodeInfosByName["right-leg"].trs.rotation[0] = -adjust;
			adjust = Math.sin(c + 0.1) * 0.4;
			nodeInfosByName["left-calf" ].trs.rotation[0] = -adjust;
			nodeInfosByName["right-calf"].trs.rotation[0] =  adjust;
			adjust = Math.sin(c + 0.1) * 0.4;
			nodeInfosByName["left-foot" ].trs.rotation[0] = -adjust;
			nodeInfosByName["right-foot"].trs.rotation[0] =  adjust;

			adjust = Math.sin(c) * 0.4;
			nodeInfosByName["left-arm" ].trs.rotation[2] =  adjust;
			nodeInfosByName["right-arm"].trs.rotation[2] =  adjust;
			adjust = Math.sin(c + 0.1) * 0.4;
			nodeInfosByName["left-forearm" ].trs.rotation[2] =  adjust;
			nodeInfosByName["right-forearm"].trs.rotation[2] =  adjust;
			adjust = Math.sin(c - 0.1) * 0.4;
			nodeInfosByName["left-hand" ].trs.rotation[2] =  adjust;
			nodeInfosByName["right-hand"].trs.rotation[2] =  adjust;

			adjust = Math.sin(c) * 0.4;
			nodeInfosByName["waist"].trs.rotation[1] =  adjust;
			adjust = Math.sin(c) * 0.4;
			nodeInfosByName["torso"].trs.rotation[1] =  adjust;
			adjust = Math.sin(c + 0.25) * 0.4;
			nodeInfosByName["neck"].trs.rotation[1] =  adjust;
			adjust = Math.sin(c + 0.5) * 0.4;
			nodeInfosByName["head"].trs.rotation[1] =  adjust;
			adjust = Math.cos(c * 2) * 0.4;
			nodeInfosByName["head"].trs.rotation[0] =  adjust;

// Compute all the matrices for rendering
			objects.forEach(function(object) {
				object.drawInfo.uniforms.u_matrix = m4.multiply(viewProjectionMatrix, object.worldMatrix);
			});

// ------ Draw the objects --------

			var lastUsedProgramInfo = null;
			var lastUsedBufferInfo = null;

			objectsToDraw.forEach(function(object) {
				var programInfo = object.programInfo;
				var bufferInfo = object.bufferInfo;
				var bindBuffers = false;

				if (programInfo !== lastUsedProgramInfo) {
					lastUsedProgramInfo = programInfo;
					gl.useProgram(programInfo.program);

// We have to rebind buffers when changing programs because we
// only bind buffers the program uses. So if 2 programs use the same
// bufferInfo but the 1st one uses only positions the when the
// we switch to the 2nd one some of the attributes will not be on.
					bindBuffers = true;
				}

// Setup all the needed attributes.
				if (bindBuffers || bufferInfo !== lastUsedBufferInfo) {
					lastUsedBufferInfo = bufferInfo;
					webglUtils.setBuffersAndAttributes(gl, programInfo, bufferInfo);
				}

// Set the uniforms.
				webglUtils.setUniforms(programInfo, object.uniforms);

// Draw
				gl.drawArrays(gl.TRIANGLES, 0, bufferInfo.numElements);
			});

			requestAnimationFrame(drawScene);
		}
	}

	main();

</script>
<script>
	(function (root, factory) {
		if (typeof define === 'function' && define.amd) {
			// AMD. Register as an anonymous module.
			define(['./transform'], factory);
		} else {
			// Browser globals
			var lib = factory();
			root.wrapCanvasRenderingContext2D = lib.wrap;
		}
	}(this, function () {
		"use strict";

		function duplicate(src) {
			const d = new window.DOMMatrix();
			d.a = src.a;
			d.b = src.b;
			d.c = src.c;
			d.d = src.d;
			d.e = src.e;
			d.f = src.f;
			return d;
		}

		function patchCurrentTransform(ctx) {

			if (ctx.currentTransform) {
				return ctx;
			}

			var stack = [];

			ctx.scale = function(scale) {
				return function(x, y) {
					ctx.currentTransform.scaleSelf(x, y);
					scale(x, y);
				};
			}(ctx.scale.bind(ctx));

			ctx.rotate = function(rotate) {
				return function(r) {
					ctx.currentTransform.rotateSelf(r * 180 / Math.PI);
					rotate(r);
				};
			}(ctx.rotate.bind(ctx));

			ctx.translate = function(translate) {
				return function(x, y) {
					ctx.currentTransform.translateSelf(x, y);
					translate(x, y);
				};
			}(ctx.translate.bind(ctx));

			ctx.save = function(save) {
				return function() {
					stack.push(duplicate(ctx.currentTransform));
					save();
				};
			}(ctx.save.bind(ctx));

			ctx.restore = function(restore) {
				return function() {
					if (stack.length) {
						ctx.currentTransform = stack.pop();
					} else {
						throw "transform stack empty!";
					}
					restore();
				};
			}(ctx.restore.bind(ctx));

			ctx.transform = function(transform) {
				return function(m11, m12, m21, m22, dx, dy) {
					const m = new DOMMatrix();
					m.a = m11;
					m.b = m12;
					m.c = m21;
					m.d = m22;
					m.e = dx;
					m.f = dy;
					ctx.currentTransform.multiplySelf(m);
					transform(m11, m12, m21, m22, dx, dy);
				};
			}(ctx.transform.bind(ctx));

			ctx.setTransform = function(setTransform) {
				return function(m11, m12, m21, m22, dx, dy) {
					const d = ctx.currentTransform;
					d.a = m11;
					d.b = m12;
					d.c = m21;
					d.d = m22;
					d.e = dx;
					d.f = dy;
					setTransform(m11, m12, m21, m22, dx, dy);
				};
			}(ctx.setTransform.bind(ctx));

			ctx.currentTransform = new DOMMatrix();

			ctx.validateTransformStack = function() {
				if (stack.length != 0) {
					throw ("transform stack not 0");
				}
			};

			return ctx;
		};

		function wrap(ctx) {
			//patchDOMMatrix();
			return patchCurrentTransform(ctx);
		}

		return {
			wrap: wrap,
		};
	}));
	"use strict";

	function duplicate(src) {
		const d = new window.DOMMatrix();
		d.a = src.a;
		d.b = src.b;
		d.c = src.c;
		d.d = src.d;
		d.e = src.e;
		d.f = src.f;
		return d;
	}

	function renderSceneGraph(root) {
		const canvas = document.getElementById("sch");
		const ctx = wrapCanvasRenderingContext2D(canvas.getContext("2d"));
		var g_update = true;

		function getRelativeMousePosition(event, target) {
			target = target || event.target;
			const rect = target.getBoundingClientRect();

			return {
				x: event.clientX - rect.left,
				y: event.clientY - rect.top,
			}
		}

		// assumes target or event.target is canvas and has no border/padding
		function getNoBorderNoPaddingRelativeMousePosition(target, event) {
			target = target || event.target;
			const pos = getRelativeMousePosition(event, target);

			pos.x = pos.x * target.width  / canvas.clientWidth;
			pos.y = pos.y * target.height / canvas.clientHeight;

			return pos;
		}

		const pointers = {
		};

		const setPointer = function(id, pos, pressed) {
			var pointer = pointers[id];
			if (!pointer) {
				pointer = { };
				pointers[id] = pointer;
			}
			pointer.pos = pos;
			if (pressed) {
				pointer.pressed = true;
			}
		};

		const clearPointer = function(id, pos) {
			var pointer = pointers[id];
			if (!pointer) {
				pointer = { };
				pointers[id] = pointer;
			}
			pointer.pos = pos;
			pointer.pressed = false;
		};
		canvas.addEventListener('pointerdown', function(e) {
			const pos = getNoBorderNoPaddingRelativeMousePosition(e.target, e);
			setPointer(e.pointerId, pos, true);
			g_update = true;
		}, true);

		canvas.addEventListener('pointermove', function(e) {
			const pos = getNoBorderNoPaddingRelativeMousePosition(e.target, e);
			setPointer(e.pointerId, pos);
			g_update = true;
		}, false);

		canvas.addEventListener('pointerup', function(e) {
			const pos = getNoBorderNoPaddingRelativeMousePosition(e.target, e);
			clearPointer(e.pointerId, pos);
			g_update = true;
		}, false);

		function inRect(ctx, width, height, x, y) {
			x = x || 0;
			y = y || 0;
			var inv = duplicate(ctx.currentTransform);
			inv.invertSelf();
//    ctx.save();
//      ctx.strokeStyle = "#0F0";
//      ctx.strokeRect(x, y, width, height);
//    ctx.restore();
			for (var id in pointers) {
				if (pointers.hasOwnProperty(id)) {
					const p = pointers[id];
					if (p.pressed) {
						const pnt = inv.transformPoint(new DOMPoint(p.pos.x, p.pos.y, 0, 1));
						if (pnt.x >= x && pnt.x < x + width &&
							pnt.y >= y && pnt.y < y + height) {
							return {
								x: (pnt.x - x) / width,
								y: (pnt.y - y) / height,
								pointer: p,
							};
						}
					}
				}
			}
		}

		const borderSize = 10;
		const height = 30;
		var somethingPressed;

		function drawArrow(node, parent) {
			ctx.save();
			ctx.rotate(node.rotation);
			ctx.translate(node.translation[0], node.translation[1]);
			const mat = duplicate(ctx.currentTransform);
			ctx.restore();
			const inv = duplicate(ctx.currentTransform);
			inv.invertSelf();
			inv.multiplySelf(mat);

			ctx.save();
			if (node.draw !== false && parent && parent.draw !== false) {
				ctx.beginPath();
				ctx.moveTo(0, 0);
				ctx.lineTo(inv.e, inv.f);
				ctx.stroke();
			}
			ctx.rotate(node.rotation);
			ctx.translate(node.translation[0], node.translation[1]);
			node.children.forEach(function(child) {
				drawArrow(child, node);
			});
			ctx.restore();
		}

		function drawNode(node) {
			ctx.save();
			ctx.rotate(node.rotation);
			ctx.translate(node.translation[0], node.translation[1]);
			const tm = ctx.measureText(node.name);
			const rx = -tm.width / 2 - borderSize;
			const ry = -height / 2;
			const width = tm.width + borderSize * 2;
			if (node.draw !== false) {
				ctx.fillStyle = node.pressed ? "#F0F" : "#0FF";
				ctx.strokeStyle = "black";
				ctx.fillRect(rx, ry, width, height);
				ctx.strokeRect(rx, ry, width, height);
				ctx.fillStyle = "black";
				ctx.strokeStyle = "black";
				ctx.fillText(node.name, 0, 1);
			} else {
				ctx.strokeStyle = "red";
				ctx.beginPath();
				ctx.moveTo(-5, -5);
				ctx.lineTo(5, 5);
				ctx.moveTo(-5, 5);
				ctx.lineTo(5, -5);
				ctx.stroke();
			}
			node.children.forEach(drawNode);

			// Check UI stuff after children since children get
			// drawn last they appear in front.
			if (node.pressed) {
				if (node.pressed.pointer.pressed) {
					const diff = node.pressed.pointer.pos.x - node.startX;
					node.rotation = node.startRot - diff * 0.01;
				} else {
					somethingPressed = false;
					node.pressed = null;
				}
			} else if (!somethingPressed) {
				if (node.draw !== false) {
					node.pressed = inRect(ctx, width, height, rx, ry);
					if (node.pressed) {
						somethingPressed = node;
						node.startRot = node.rotation;
						node.startX   = node.pressed.pointer.pos.x;
					}
				}
			}


			ctx.restore();
		}

		function drawScene() {
			webglUtils.resizeCanvasToDisplaySize(ctx.canvas);
			ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
			ctx.save();
			ctx.translate(ctx.canvas.width / 2, 40);
//    var scale = window.devicePixelRatio * ctx.canvas.height / 1000;
//    ctx.scale(scale, scale);
			ctx.font = "12px sans-serif";
			ctx.textAlign = "center";
			ctx.textBaseline = "middle";
			drawArrow(root);
			drawNode(root);
			ctx.restore();
		}

		function render() {
			if (g_update) {
				g_update = false;
				drawScene();
			}

			requestAnimationFrame(render, canvas);
		}
		render();
	}
</script>
<script>

	"use strict";

	function main() {

		var root = {
			name: "center of universe",
			translation: [0, 0],
			children: [
				{
					name: "andromeda galaxy",
					translation: [-5, 1],
					children: [
					],
				},
				{
					name: "milky way galaxy",
					translation: [5, 1],
					children: [
						{
							name: "betelgeuse",
							translation: [-10, 1],
							children: [
							],
						},
						{
							name: "sun",
							translation: [-4, 1],
							children: [
								{
									name: "earth",
									translation: [-5, 1],
									children: [
										{
											name: "moon",
											translation: [-1, 1],
											children: [
											],
										},
									],
								},
								{
									name: "venus",
									translation: [0, 1],
									children: [
									],
								},
								{
									name: "mars",
									translation: [5, 1],
									children: [
										{
											name: "phobos",
											translation: [-3, 1],
											children: [
											],
										},
										{
											name: "deimos",
											translation: [3, 1],
											children: [
											],
										},
									],
								},
							],
						},
						{
							name: "alpha centari",
							translation: [3, 1],
							children: [
							],
						},
					],
				},
			],
		};

		var xSpread = 16;
		var ySpread = 100;
		function updateTranslation(node) {
			node.translation[0] *= xSpread;
			node.translation[1] *= ySpread;
			node.rotation = 0;
			node.children.forEach(updateTranslation);
		}
		updateTranslation(root);
		renderSceneGraph(root);
	}
	main();

</script>
